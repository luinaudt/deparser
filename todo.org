#+TITLE: P4 deparser implementation on FPGA
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS

* Introduction

** Problematique
- Cas de travail : 
| entete | taille (bits) |
| Eth    |           112 |
| IP     |           160 |
| TCP    |           160 |



 - Nombre de combinaisons de sorties : 2^n-1 avec n nombre d'état
 - Nombre d'entrée dans les multiplexeur :
   - Si aucune optimisation neaucoup d'entrée dans un mux
   - Eth, IP, TCP :
     - combinaisons sans optimisation : Eth; IP; TCP; Eth, IP; Eth,IP,TCP; IP,TCP; Eth, TCP
     - Avec optimisation : Eth; Eth,IP; Eth,IP,TCP;
     - Implication entrées muxes avec un bus de sortie de 64bits pour le bit(0):
       
          | Sans optimisation | Avec Optimisation |
          |-------------------+-------------------|
          | Eth(0)            | Eth(0)            |
          | Eth(64)           | Eth(64)           |
          | IP(0)             | IP(16)            |
          | IP(16)            | IP(80)            |
          | IP(64)            | IP(144)           |
          | IP(80)            | TCP(48)           |
          | IP(128)           | TCP(112)          |
          | IP(144)           |                   |
          | TCP(0)            |                   |
          | TCP(16)           |                   |
          | TCP(32)           |                   |
          | TCP(48)           |                   |
          | TCP(64)           |                   |
          | TCP(80)           |                   |
          | TCP(96)           |                   |
          | TCP(112)          |                   |
          | TCP(128)          |                   |
          | TCP(144)          |                   |
          | Tot : 18          | Tot : 7           |
          | LUT est : 9       | LUT est : 2       |

     - Bus de 128 bits : bit(0)
          | Sans optimisation | Avec Optimisation |
          |-------------------+-------------------|
          | Eth(0)            | Eth(0)            |
          | IP(0)             | IP(16)            |
          | IP(16)            | IP(144)           |
          | IP(128)           | TCP(112)          |
          | IP(144)           |                   |
          | TCP(0)            |                   |
          | TCP(16)           |                   |
          | TCP(96)           |                   |
          | TCP(112)          |                   |
          | TCP(128)          |                   |
          | TCP(144)          |                   |
          | Tot : 11          | Tot : 4           |
          | Lut est : 3       | LUT est : 1       |



      

** Objectif
*** Généraux
 - regarder une architecture efficace pour un deparser sur FPGA
 - Voir l'intéret pour l'optimisation du graphe de deparsage.
 - Efficacité de l'utilisation de cocotb

*** Métriques
 - Ressource / entête / taille
 - Gain par l'optimisation du graphe
 - Précision de prédiction

*** Hypothèses
  - Les protocoles supporté sont défini dans le P4
  - On réimplémente le code P4 à chaque changement
  - L'architecture doit être automatiquement générée.

** Contribution
*** New architecture
 
*** Compiler
 
*** Test (cocotb)
 

** Architecture overview

*** Test platform
Cocotb allows :
  - Simpler test framework
  - Packet generation
  - Python integration
  - Focus on the test not the details

*** Hardware design
- Takes a PHV and Payload as input.
  - Payload on AXI4stream interface
  - PHV Bus :
    - A bus of all header
    - Each Header has a validity bit.
- Generates an AXI stream packet output
- Muxes
  - connect some element of PHV to output bus.
  - Control with a state machine
  - 1 state machine per mux, can be seen as a /VLIW/
- Inputs of muxes and state machines depend on the P4 code

*** Compiler
- Optimize the graphs
- Generate VHDL
- Use Json from P4c ?

** Implementation results

*** test on a real platform ?

*** Maximum throughput

*** Ressource consumption 
- Comparison with Xilinx
- Comparison with netcope ?

*** Impact of graph reduction

*** Compilation time ?

** related work
- NetFPGA
- Netcope
- Xilinx SDNet
- Parsers ?

  
* Hardware [0%]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :ORDERED:  t
  :END:
** TODO Eth-IPv4-TCP 
*** TODO Ordre indépendant
*** TODO Ordonné
** TODO Eth-IPv4-TCP-Payload
*** TODO Ordre indépendant
*** TODO Ordonné
** TODO Eth-IPv4-IPv6-TCP-Payload
*** TODO Ordre indépendant
*** TODO Ordonné
** TODO Eth-IPv4-IPv6-TCP-UDP-Payload
*** TODO Ordre indépendant
*** TODO Ordonné

    
* Simulation [29%]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :ORDERED:  t
  :END:
** TODO Monitor
*** DONE Monitor AXI-stream packets
*** DONE structure of received values ?
    - Fonctions utile faite pour convertir les paquets en format BinaryValue et scapy
    - Les transaction sont des BinaryValue utilisé par le scoreboard
    - Il est possible de déterminer les transcation à l'aide des fonctions utiles
** TODO scapy to PHV
*** TODO headers to PHV
**** DONE simple header with signals
     Function to assign and parse
**** DONE validate byte order
**** TODO check on autogeneration
**** TODO Generate parser file for function
**** TODO set expected output from monitor
*** TODO Payload
** [25%] model.py
*** TODO structure of the file
- How do we represent function
- Standard input output
*** TODO parser model
*** TODO deparser model
*** DONE convertion between BinaryValue and scapy
** TODO PHV to axi-stream
*** TODO the deparser

    
* Compilation [0%]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :ORDERED:  t
  :END:
** TODO JSON to VHDL
** TODO JSON to cocotb
** TODO Optimization
*** TODO Eth-IP-TCP (only one possible futur header)
*** TODO Eth-IPv4-IPv6-TCP (2 paths)
*** TODO Eth-IPv4-IPv6-TCP-UDP (4 paths)
*** TODO Add header
*** TODO remove header
*** TODO conditionnal add
*** TODO conditionnal remove
